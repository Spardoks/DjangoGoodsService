# Дипломный проект - Backend-приложение для автоматизации закупок

## Цели

- разработать backend для сервиса заказа товаров,
- усовершенствовать с Django ORM проработку моделей товаров и связанных сущностей,
- реализовать импорт и экспорт товаров,
- внедрить систему управления заказами,
- оптимизировать методы с использованием асинхронности
- подготовить документацию к проекту

Референс - https://github.com/netology-code/python-final-diplom


## Общее описание проекта

Приложение предназначено для автоматизации закупок в розничной сети через REST API.
Все взаимодействие с приложением ведется через API запросы. Реализация фронтенд-приложения возможна только по желанию обучающегося


### Пользователи приложения

Клиент (покупатель):
- делает ежедневные закупки по каталогу, в котором представлены товары от нескольких поставщиков,
- в одном заказе можно указать товары от разных поставщиков,
- пользователь может авторизироваться, регистрироваться и восстанавливать пароль через API.

Поставщик(администратор магазина):
- через API информирует сервис об обновлении прайса,
- может включать и отключать приём заказов,
- может получать список оформленных заказов (с товарами из его прайса).


### Основной сценарий использования

#### Клиент

1. Регистрация/восстановление пароля/вход
2. Выбор фильтров в каталоге товаров
   - Выбор магазинов (по необходимости)
   - Выбор категории (по необходимости)
2. Выбор товара = получение подробной информации о нём
3. Выбор количества, цены/магазина = добавление товаров в корзину
4. Просмотр корзины и её редактирование(удаление из неё товаров)
5. Добавление контактов для связи и доставки
6. Подтверждение заказа (без оплаты, сразу отсылка заказов поставщикам и уведомление их через email и клиентов о созданном заказе тоже)
7. Проверка статуса заказа
8. Получение контактов о поставщиках каждого товара для дополнительной связи


#### Поставщик

1. Регистрация/восстановление пароля/вход
2. Добавление контактов для связи, адреса магазина
3. Импорт информации о товарах в своём магазине (обновление цен = импорт нового списка товаров)
4. Просмотр заказов от клиентов
5. Получение контактов клиентов для каждого заказа для доп.связи
6. Изменение статуса заказа клиентов (сразу отсылка или отмена заказов клиентам и уведомление их через email)


## Задачи

Базовая часть:
- разработка сервиса под готовую спецификацию (API),
- возможность добавления настраиваемых полей (характеристик) товаров,
- импорт товаров,
- отправка накладной на email администратора (для исполнения заказа),
- отправка заказа на email клиента (подтверждение приёма заказа).

Продвинутая часть (необязательная к выполнению, не влияет на получение зачёта):
- экспорт товаров,
- админка заказов (проставление статуса заказа и уведомление клиента),
- выделение медленных методов в отдельные асинхронные функции (email, импорт, экспорт).


В репозитории приведён готовый пример с базовой частью проекта. Можно работать с проектом, выбрав один из двух вариантов:
- разработать свою версию, исходя из текстового описания базовой части проекта,
- взять за основу пример из репозитория, изучить его и выполнить продвинутую часть задания.

https://github.com/A-Iskakov/netology_pd_diplom

Можно также интерпретировать текстовое описание проекта по-своему. Работа над дипломом - это в первую очередь творческий процесс. Главное - отсутствие плагиата (не сдавать работы других студентов).


## Этапы базовой части

Этап 1. Создание и настройка проекта
https://github.com/netology-code/python-final-diplom/blob/master/reference/step-1.md

Этап 2. Проработка моделей данных
https://github.com/netology-code/python-final-diplom/blob/master/reference/step-2.md

Этап 3. Реализация импорта товаров
https://github.com/netology-code/python-final-diplom/blob/master/reference/step-3.md

Этап 4. Реализация APIViews
https://github.com/netology-code/python-final-diplom/blob/master/reference/step-4.md

Этап 5. Полностью готовый backend
https://github.com/netology-code/python-final-diplom/blob/master/reference/step-5.md


## Прогресс выполнения

### Этап 1, Создание и настройка проекта

Начало: 
- install python 3.10+ (https://www.python.org/downloads/release/python-3100/)
- python -m venv venv
- source venv/Scripts/activate
- pip install -r requirements.txt
- django-admin startproject GoodsService .
- python manage.py startapp backend
- python manage.py runserver
- goto http://127.0.0.1:8000/

Продолжение
- git clone
- create venv
- activate venv
- pip install
- python manage.py makemigrations
- python manage.py migrate
- python manage.py runserver
- goto http://127.0.0.1:8000/


### Этап 2, Проработка моделей данных

Можно создать следующие [модели](./backend/models.py) на основе анализа
- общего описания задач
- описания приложения и основных сценариев - https://github.com/netology-code/python-final-diplom/blob/master/reference/service.md
- особенностей точек входа приложения - https://github.com/netology-code/python-final-diplom/blob/master/reference/screens.md
- особенностей импортируемых заготовленных данных - https://github.com/netology-code/python-final-diplom/blob/master/data/shop1.yaml
- примерной спецификации api - https://documenter.getpostman.com/view/5037826/SVfJUrSc#a7ed103f-3429-415d-a7d5-c6f0d3ac9649
- референса - https://github.com/netology-code/python-final-diplom/blob/master/reference/step-2.md (полный пример можно найти тут https://github.com/A-Iskakov/netology_pd_diplom/blob/master/backend/models.py) 


#### 1. Добавляем свою модель пользователя и вспомогательных методов для него, не забыв указать в settings использовать свою модель
- для тестирования можно выполнить
  - python manage.py makemigrations
  - python manage.py migrate
  - python manage.py createsuperuser
  - python manage.py runserver
  - goto http://127.0.0.1:8000/admin
- также протестировать можно через shell
  - python manage.py shell
  - from backend import User
  - create or do smth
- также можно попробовать через pytest
  - pip install pytest-django
  - pytest tests/backend/test_user_model.py

#### 2. Добавляем другие модели
- Shop
- Category
- Product
- ProductInfo
- Parametr
- ProductParameter
- Contact
- Order
- OrderItem

Пока всё, если ещё понадобится, добавим в других этапах

### Этап 3, Реализация импорта товаров
- Подготовлен пример view, на основе которого можно будет по образу и подобию составить view для импорта 
- Подготовлен пример импорта в бд данных магазина на основе тестовых данных из файла, на оснвове которого можно будет сформировать логику view для импорта
- Подготовлена функция, которая может быть использованя для импорта загруженных любым способом (из файла, по сети) данных
- Подговлен view для импорта товаров (пока без проверки аутентицикации) в магазин для определённого пользователя-владельца

### Этап 4. Реализация APIViews
Реализованы API views для основных точек входа сервиса (без админки).
- [x] Вход
- [x] Регистрация
- [x] Список товаров
- [x] Корзина (просмотр, добавление, удаление)
- [x] Контакты (просмотр, добавление, удаление)
- [x] Подтверждение заказа
- [x] Просмотр контактов магазинов из заказов
- [x] Заказы, просмотр списка для пользователя-владельца магазина
- [x] Заказы, изменение статуса заказа магазином

#### Про регистрацию и вход
На первое время выбран способ регистарции по пользователю и паролю, а успешный вход предполагает получение токена, реализованного модулем аутентификации rest_framework.authentication.TokenAuthentication.

После добавления данного модуля была проведена миграция бд.

Добавлены тестовые view и тесты-примеры для тестирования данного подхода входа, регистрации и использования токена аутентификации

#### Про просмотр контактов магазинов из заказов
Был добавлен эндпоинт shops, который возвращает описания всех актвиных или выбранного магазина с email его владельца для возможности связи.
Сейчас в заказах пользователей указаны id магазинов. Таким образом, если необходимо, то можно будет получить контакты для связи по поводу заказов.

#### Про просмотр контактов клиентов магазинами
Сейчас про получении заказов в них будут находиться контакты клиентов

#### Про заказы, изменение статуса заказа магазином
Сейчас, чтобы из корзины создался заказ необходимо для корзины послать определённый метод с контактом.  
После этого корзина превращается в заказ со статусом new.  
В заказе могут быть продукты с разных магазинов.  
Магазины могут получить заказы, в которых присутствуют их продукты.  
Если магазин захочет изменить статус какого-нибудь заказа, в который входят его продукты, то этот новый статус как будто бы изменится и для дргугого магазина, чиьи продукты входят в тот же заказ.  


Если мы всё же хотим добавить возможность магазинам изменять статусы заказов, не затрагивая другие магазины, необходимо это как-то правильно согласовать.
- Например, договориться и/или внедрить в код логику, при которой в одну корзину можно добавить только товары из одного магазина.
- Если не договариваться и ничего не внедрять в код, то работа с одним магазином будет корректна и ничего согласовать не нужно. Хотя тут тоже нюанс - менять статус как будто бы удобнее не по всем товарам сразу, а по каждому в отдельности
- Соответственно, с учётом размышлений выше, как будто бы для обобщения более корректно при создании заказа стоит корзину дробить на orderItems и для каждого orderItems создавать отдельный order со статусом new и переданным контатком
- Или, например, статус заказа пользователя оставить общим для всех продуктов в заказе - basket, created, closed, и хранить для каждого odrderItem в заказе статус, с которым и будет работать магазин - тогда надо будет создавать таблицу id заказа,id orderItem, status. При изменении status магазинами в данной таблице проверять, не нужно ли изменить статус всего заказа. Создавать такую таблицу надо будет при создание пользователем заказа, а если соединить такую таблицу по orderItem с магазинами, то магазины довольно быстро будут понимать, какие у них есть заказы


### Этап 5. Полностью готовый backend (ToDo)

1. Полностью работающие API Endpoint.
2. Корректно отрабатывает следующий сценарий:
- [x] пользователь может авторизоваться;
- [x] есть возможность отправки данных для регистрации и получения email с подтверждением регистрации;
- пользователь может добавлять в корзину товары от разных магазинов;
- [x] пользователь может создавать контакты (адреса доставки)
- [x] пользователь может подтверждать заказ;
- [x] пользователь получает email с подтверждением после ввода адреса доставки;
- [x] пользователь может получать список заказов.

#### По сути осталось:
- ToDo: тест на работу с несколькими магазинами

### Уделить внимание, если получится
- ToDo: пока договариваемся для упрощения работы в один заказ добавлять только заказы одного магазина и оповещать сервисом об изменении статуса заказов сразу по всем товарам из его заказа - но стоит обобщить в дальнейшем, так как это более корректный путь работы сервиса - договариваемся о таком, чтобы магазины меняли статусы заказов независимо, иначе будут пересечения сейчас, но работать будет, конечно.
- ToDo: postgres
- ToDo: prod web server
- ToDo: docker
- ToDo: allure и размещение логически связанных api тестов в различные файлы
- ToDo: все эндпоинты по спецификации - более строгая проверка, в особенности reset_password
- ToDo: автоматическая документация
- ToDo: вынести из requirements.txt тестовый req aiosmtpd (и другие, которые не используются для работы сервиса) в test_reqs.txt
- ToDo: убрать тестовые эндпоинты

### Уделить внимание когда-нибудь
- ci/cd
- экспорт товаров
- админка заказов (проставление статуса заказа и уведомление клиента)
- выделение медленных методов в отдельные асинхронные функции (email, импорт, экспорт)
- prod smtp (docker, например)
- большее покрытие тестами и более явная связь их с требованиями